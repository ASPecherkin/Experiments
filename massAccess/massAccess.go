package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"net"
	"os"
	"runtime/pprof"
	"sync"
	"time"
)

type cidr struct {
	Cidrs []string `json:"cidrs"`
}

func parseCidrs(path string) (c cidr, err error) {
	data, err := ioutil.ReadFile("./hosts.json")
	if err != nil {
		log.Fatalf("Couldn't read config file: %s  \n", err)
		return c, err
	}
	err = json.Unmarshal(data, &c)
	return c, nil
}

//Hosts return slice of hosts from given cidr address
func Hosts(cidr string) ([]string, error) {
	ip, ipnet, err := net.ParseCIDR(cidr)
	if err != nil {
		return nil, err
	}
	var ips []string
	for ip := ip.Mask(ipnet.Mask); ipnet.Contains(ip); inc(ip) {
		ips = append(ips, ip.String())
	}
	// remove network address and broadcast address
	return ips[1 : len(ips)-1], nil
}

//  http://play.golang.org/p/m8TNTtygK0
func inc(ip net.IP) {
	for j := len(ip) - 1; j >= 0; j-- {
		ip[j]++
		if ip[j] > 0 {
			break
		}
	}
}

func checkAccess(wait *sync.WaitGroup, adr string) bool {
	defer wait.Done()
	_, err := net.DialTimeout("tcp", adr, 3*time.Second)
	if err != nil {
		return false
	}
	fmt.Println(adr, true)
	return true
}

type address struct {
	IPPort string
	Status bool
}

// Server - one unit generated by cidr
type Server struct {
	Cidr  string
	Hosts []address
}

func (s *Server) checkIP(wg *sync.WaitGroup) {
	defer wg.Done()
	var wait sync.WaitGroup
	ports := [3]string{":5228", ":5229", ":5230"}
	hosts, err := Hosts(s.Cidr)
	if err != nil {
		log.Fatal(err)
	}
	for k := range hosts {
		for j := range ports {
			adr := hosts[k] + ports[j]
			wait.Add(1)
			go checkAccess(&wait, adr)
		}
	}
	wait.Wait()
}

var cpuprofile = flag.String("cpuprofile", "", "write cpu profile to file")
var memprofile = flag.String("memprofile", "", "write mem profile to file")

func main() {
	flag.Parse()
	if *cpuprofile != "" {
		f, err := os.Create(*cpuprofile)
		if err != nil {
			fmt.Println("Error: ", err)
		}
		pprof.StartCPUProfile(f)
		defer pprof.StopCPUProfile()
	}
	if *memprofile != "" {
		f, err := os.Create(*memprofile)
		if err != nil {
			fmt.Println("Error: ", err)
		}
		pprof.WriteHeapProfile(f)
	}
	var wg sync.WaitGroup
	cidrs, err := parseCidrs("./hosts.json")
	if err != nil {
		log.Fatal(err)
	}
	servers := make([]Server, 0, 10)
	for k := range cidrs.Cidrs {
		servers = append(servers, Server{Cidr: cidrs.Cidrs[k]})
	}
	fmt.Println(len(servers))
	for k := range servers {
		wg.Add(1)
		go servers[k].checkIP(&wg)
	}
	wg.Wait()
}
